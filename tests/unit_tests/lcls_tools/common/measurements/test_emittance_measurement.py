# Built in
import json
from unittest import TestCase
from unittest.mock import MagicMock

import numpy as np
import yaml

from lcls_tools.common.devices.magnet import Magnet, MagnetMetadata
from lcls_tools.common.devices.screen import Screen
from lcls_tools.common.measurements.emittance_measurement import QuadScanEmittance
from lcls_tools.common.measurements.screen_profile import ScreenBeamProfileMeasurement


# Local imports


class EmittanceMeasurementTest(TestCase):
    def test_measure_with_mocked_beamsize_measurement(self):
        """
        Test to verify correct emittance calculation based on data generated from a
        basic cheetah simulation of a quad and drift element
        """

        # Prepare mock data (generated by cheetah simulation)
        k = np.linspace(-10, 10, 10)
        x_data = np.array(
            [2.11004182e-04, 1.61777833e-04, 1.14536742e-04, 7.24512720e-05,
             4.95130807e-05, 6.79336517e-05, 1.07842716e-04, 1.52933266e-04,
             1.99458518e-04, 2.46393640e-04
             ]) * 1e6
        y_data = np.array(
            [6.22674183e-04, 5.12518862e-04, 4.05981787e-04, 3.07886046e-04,
             2.30726553e-04, 2.01972667e-04, 2.41091911e-04, 3.25417204e-04,
             4.29859007e-04, 5.43555594e-04
             ]) * 1e6

        mock_beamsize_measurements = []
        for i, val in enumerate(k):
            results = MagicMock()
            results.rms_size = [float(x_data[i]), float(y_data[i])]
            mock_beamsize_measurements += [{"fit_results": [results]}]

        # External list to return beam sizes
        external_list = iter(mock_beamsize_measurements)

        # Mock beamsize_measurement
        mock_beamsize_measurement = MagicMock(spec=ScreenBeamProfileMeasurement)
        mock_beamsize_measurement.device = MagicMock(spec=Screen)
        mock_beamsize_measurement.device.resolution = 1.0
        mock_beamsize_measurement.measure = MagicMock(
            side_effect=lambda _: next(external_list)
        )

        # Mock magnet
        mock_magnet = MagicMock(spec=Magnet)
        mock_magnet.metadata = MagnetMetadata(
            area="test",
            beam_path=["test"],
            sum_l_meters=None,
            l_eff=0.1
        )

        def mock_function(scan_settings, function):
            for ele in scan_settings:
                function()

        mock_magnet.scan = mock_function

        # define rmat and design twiss
        # design twiss set such that the 5th element of the quad scan is the design
        # setting
        rmat = np.array([[[1, 1.0], [0, 1]], [[1, 1.0], [0, 1]]])
        design_twiss = {
            "beta_x": 0.2452,
            "alpha_x": -0.1726,
            "beta_y": 0.5323,
            "alpha_y": -1.0615,
        }

        # Instantiate the QuadScanEmittance object
        quad_scan = QuadScanEmittance(
            energy=1e9 * 299.792458 / 1e3,
            scan_values=k,
            magnet=mock_magnet,
            beamsize_measurement=mock_beamsize_measurement,
            n_measurement_shots=1,
            rmat=rmat,
            design_twiss=design_twiss,
            wait_time=1e-3,
        )

        # Call the measure method
        results = quad_scan.measure()

        # Assertions
        assert "x_rms" in results
        assert "y_rms" in results
        assert len(results["x_rms"]) == len(quad_scan.scan_values)
        assert len(results["y_rms"]) == len(quad_scan.scan_values)

        # check resulting calculations against cheetah simulation ground truth
        assert np.allclose(
            results["emittance"],
            np.array([1.0e-2, 1.0e-1]).reshape(2, 1),
        )
        assert np.allclose(results["beam_matrix"], np.array(
            [[5.0e-2, -5.0e-2, 5.2e-2],
             [0.3, -0.3, 0.33333328]]
        ))
        assert np.allclose(results["BMAG"][:, 4], 1.0)

    def test_serialization(self):
        info = """  
        OTR11:
            controls_information:
              PVs:
                image: OTRS:LI21:237:IMAGE
                n_bits: OTRS:LI21:237:N_OF_BITS
                n_col: OTRS:LI21:237:N_OF_COL
                n_row: OTRS:LI21:237:N_OF_ROW
                resolution: OTRS:LI21:237:RESOLUTION
              control_name: OTRS:LI21:237
            metadata:
              area: BC1
              beam_path:
              - CU_ALINE
              - CU_HTXI
              - CU_HXR
              - CU_HXTES
              - CU_SFTH
              - CU_SXR
              sum_l_meters: 34.834
              type: PROF
        CQ11:
            controls_information:
              PVs:
                bact: QUAD:LI21:221:BACT
                bcon: QUAD:LI21:221:BCON
                bctrl: QUAD:LI21:221:BCTRL
                bdes: QUAD:LI21:221:BDES
                bmax: QUAD:LI21:221:BMAX
                bmin: QUAD:LI21:221:BMIN
                ctrl: QUAD:LI21:221:CTRL
              control_name: QUAD:LI21:221
            metadata:
              area: BC1
              beam_path:
              - CU_ALINE
              - CU_HTXI
              - CU_HXR
              - CU_HXTES
              - CU_SFTH
              - CU_SXR
              l_eff: 0.108
              sum_l_meters: 31.89
              type: QUAD
        """
        config = yaml.safe_load(info)
        screen = Screen.model_validate(config["OTR11"])
        magnet = Magnet.model_validate(config["CQ11"])

        beamsize_measurement = ScreenBeamProfileMeasurement(device=screen)

        rmat = np.array([[[1, 1.0], [0, 1]], [[1, 1.0], [0, 1]]])
        design_twiss = {
            "beta_x": 0.2452,
            "alpha_x": -0.1726,
            "beta_y": 0.5323,
            "alpha_y": -1.0615,
        }
        k = np.linspace(-10, 10, 10)

        quad_scan = QuadScanEmittance(
            energy=1e9 * 299.792458 / 1e3,
            scan_values=k,
            magnet=magnet,
            beamsize_measurement=beamsize_measurement,
            n_measurement_shots=1,
            rmat=rmat,
            design_twiss=design_twiss,
            wait_time=1e-3,
        )

        # check to make sure info is in serialized dump
        quad_scan_dump = json.loads(quad_scan.model_dump_json())
        assert quad_scan_dump["scan_values"] == k.tolist()
        assert quad_scan_dump["magnet"]["controls_information"]["PVs"]["bctrl"] == \
               "QUAD:LI21:221:BCTRL"
        assert quad_scan_dump["beamsize_measurement"]["device"][
            "controls_information"]["PVs"]["image"] == "OTRS:LI21:237:IMAGE"
        assert "image_processor" in quad_scan_dump["beamsize_measurement"]["beam_fit"]
        assert quad_scan_dump["rmat"] == [
            [[1.0, 1.0], [0.0, 1.0]], [[1.0, 1.0], [0.0, 1.0]]
        ]

        with open('data.yml', 'w') as outfile:
            yaml.dump(quad_scan_dump, outfile, default_flow_style=False)


